{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Overview The Physical Quantities Calculating class library is developed in the Python 3.8.5 environment and is a class library that handles the calculating of physical quantities and the conversion of the measurement units. This library is fully close to the concept of physical quantity, and emphasizes the relationship between physical quantities. Automatically generate a new quantity after calculation, which is closer to the domain knowledge of quantity calculation. It can also handle unit conversion between SI unit . Feature There is only a simple interface for the arithmetic calculation of physical quantities and the selection of measurement units. New types of physical quantities are automatically generated for calculation and automatic unit conversion. It can handle most of the SI unit system units and non-SI unit system units selected by the SI unit system. For example, the minute, hour, day, month, and year of time, etc. By simply subclassing the base class method, new physical quantities and their units of measurement can be easily generated for easy expansion. Use Identity to express the concept of unitless quantity. Install install frow PyPi pip install quantities download download from git Usage 1 2 3 4 5 6 7 8 9 10 11 import quantities as pq l = pq . Length ( 33 ) t = pq . Time ( 11 ) v = l / t print ( v . value ) print ( v . current_unit . express_by_SI_base ()) print () a = v / t print ( a . value ) print ( a . current_unit . express_by_SI_base ()) The results after running the program are as follows: 1 2 3 4 5 6 7 8 9 10 3.0 ( 'm/s' , 'm/s' ) 0.2727272727272727 ( 'm \\\\ cdot s^{-2}' , 'm\u00b7s<sup>-2</sup>' ) ( 'km \\\\ cdot s^{-2}' , 'km\u00b7s<sup>-2</sup>' ) ( 'MN \\\\ cdot m' , 'MN\u00b7m' ) ( 'Mkg \\\\ cdot m^ {2} \\\\ cdot s^{-2}' , 'Mkg\u00b7m<sup>2</sup>\u00b7s<sup>-2</sup>' )","title":"index"},{"location":"index.html#overview","text":"The Physical Quantities Calculating class library is developed in the Python 3.8.5 environment and is a class library that handles the calculating of physical quantities and the conversion of the measurement units. This library is fully close to the concept of physical quantity, and emphasizes the relationship between physical quantities. Automatically generate a new quantity after calculation, which is closer to the domain knowledge of quantity calculation. It can also handle unit conversion between SI unit .","title":"Overview"},{"location":"index.html#feature","text":"There is only a simple interface for the arithmetic calculation of physical quantities and the selection of measurement units. New types of physical quantities are automatically generated for calculation and automatic unit conversion. It can handle most of the SI unit system units and non-SI unit system units selected by the SI unit system. For example, the minute, hour, day, month, and year of time, etc. By simply subclassing the base class method, new physical quantities and their units of measurement can be easily generated for easy expansion. Use Identity to express the concept of unitless quantity.","title":"Feature"},{"location":"index.html#install","text":"","title":"Install"},{"location":"index.html#install-frow-pypi","text":"pip install quantities","title":"install frow PyPi"},{"location":"index.html#download","text":"download from git","title":"download"},{"location":"index.html#usage","text":"1 2 3 4 5 6 7 8 9 10 11 import quantities as pq l = pq . Length ( 33 ) t = pq . Time ( 11 ) v = l / t print ( v . value ) print ( v . current_unit . express_by_SI_base ()) print () a = v / t print ( a . value ) print ( a . current_unit . express_by_SI_base ()) The results after running the program are as follows: 1 2 3 4 5 6 7 8 9 10 3.0 ( 'm/s' , 'm/s' ) 0.2727272727272727 ( 'm \\\\ cdot s^{-2}' , 'm\u00b7s<sup>-2</sup>' ) ( 'km \\\\ cdot s^{-2}' , 'km\u00b7s<sup>-2</sup>' ) ( 'MN \\\\ cdot m' , 'MN\u00b7m' ) ( 'Mkg \\\\ cdot m^ {2} \\\\ cdot s^{-2}' , 'Mkg\u00b7m<sup>2</sup>\u00b7s<sup>-2</sup>' )","title":"Usage"},{"location":"API%20Reference.html","text":"API Reference The API of Physical Quantity Calculating mainly includes the arithmetic and comparison of Quantity class, as well as the operation of transforming units such as to_unit . We also need to pay special attention to the register method of QuantityType. The methods of the Unit class are also very interesting, involving unit conversion and unit writing expression. API of the Quantity class Quantity is the main class for programming to operate, and it is the base class for all physical quantities\u3002It has arithmetic operations and comparison operations, in particular it also has conversion unit operations, these operations realize the calculation of the number and the conversion of units. It is an operation that is often used in programming. Arithmetic operations Quantity.add(self, other) :\u3000This method provides operation of the same type of physical quantity. If the parameter other is not of the same type, a ValueError exception will be thrown.\u3000The method returns a physical quantity whose type is the same as the type of the physical quantity participating in the operation. The unit is the SI coherent unit of the physical quantity. Quantity.substract(self, other) :\u3000This method provides operation of the same type of physical quantity. If the parameter other is not of the same type, a ValueError exception will be thrown. The method returns a physical quantity whose type is the same as the type of the physical quantity participating in the operation. The unit is the SI coherent unit of the physical quantity. Quantity.multiply(self, other) :\u3000This method returns the product of the physical quantity and other types of parameters. The system will Can return diversified results. If the parameter other is of type float or int, the return result is a physical quantity whose type is the same as this physical quantity, and the unit is the same as this physical quantity, except that its value is equal to the result of multiplying the value of this physical quantity with other. When other is an ohter non-Quantity type, a ValueError exception will be thrown When ohter is a subtype Identity of Quantity, or when the physical quantity is Identity, the returned result is the same as the first case. If other is of type Quantity or its subtypes, but the system cannot determine the type after multiplication, it will throw TypeError exception. The following is an example of the application. Please carefully observe the running results of this example program. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from quantities import length from quantities import identity from quantities import time from quantities import velocity l = length . Length ( 32 , unit = length . LengthType . mu_unit ) i = identity . Identity ( 24 ) v = velocity . Velocity ( 32 ) t = time . Time ( 12 ) l1 = l . multiply ( 24 ) l2 = l . multiply ( i ) l3 = v . multiply ( t ) print ( l1 . value ) print ( l1 . current_unit . symbol ()) print ( l2 . value ) print ( l2 . current_unit . symbol ()) print ( l3 . value ) print ( l3 . current_unit . symbol ()) try : l . multiply ( v ) except TypeError : print ( \"A TypeError is thrown!\" ) The running results of the program are as follows: 1 2 3 4 5 6 7 768 ( ' \\\\ mu m' , '\u03bcm' ) 0.000768 ( 'm' , 'm' ) 384.0 ( 'm' , 'm' ) A TypeError is thrown ! l1 is an result of the length quantity multiplied by an integer, so it is still a length quantity, and its current unit is still \u03bcm. And l2 is an result of the length quantity multiplied by an instance of the Identity quantity, the it is still the length quantity, but its unit is the SI coherent unit of this quantity. We provide an interface for multiplying integers or floating-point numbers, but we still recommend using a physical quantity to multiply an instance of Identity, so that the physical concept is clearer. Quantity.__mul__(self, other) Quantity.__rmul__(self, other) These two functions are magic methods of the python class, which also express multiplication, and the __rmul__ () method expresses the concept of right multiplication. With these two functions, we can write the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from quantities import length from quantities import identity from quantities import time from quantities import velocity l = length . Length ( 32 , unit = length . LengthType . mu_unit ) i = identity . Identity ( 24 ) v = velocity . Velocity ( 32 ) t = time . Time ( 12 ) l1 = l . multiply ( 24 ) l2 = l . multiply ( i ) l3 = v . multiply ( t ) l1 = 24 * l l1 = l * 24 l2 = i * l l2 = l * i l3 = v * t l3 = t * v try : v * l except TypeError : pass try : l * v except TypeError : pass The running result is consistent with the running result of the sample code of the Quantity.multiply method. Quantitiy.divide(self, other) Quantity.__truediv__(self, other) The functions of these two functions are the same, and both express the division of physical quantities. According to the different types of the parameter ohter, the system will return different results. If the parameter other is of type float or int, the return result is a physical quantity whose type is the same as this physical quantity, and the unit is the same as this physical quantity, except that its value is equal to the result of dividing the value of this physical quantity with other. When other is an ohter non-Quantity type, a ValueError exception will be thrown When ohter is a subtype Identity of Quantity, or when the physical quantity is Identity, the returned result is the same as the first case. If other is of type Quantity or its subtypes, but the system cannot determine the type after division, it will throw TypeError exception. Based on these characteristics, we can write the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from quantities import force from quantities import time from quantities import length f = force . Force ( 53 , force . ForceType . k_unit ) t = time . Time ( 5 , time . TimeType . minute ) l = length . Length ( 33 , length . LengthType . k_unit ) v = l . divide ( t ) v = l / t a = v . divide ( t ) a = v / t m = f . divide ( a ) m = f / a print ( v . value ) print ( v . current_unit . express_by_SI_base ()) print ( a . value ) print ( a . current_unit . express_by_SI_base ()) print ( m . value ) print ( m . current_unit . symbol ()) The results of this code snippet are as follows: 1 2 3 4 5 6 110.0 ( 'm/s' , 'm/s' ) 0.36666666666666664 ( 'm \\\\ cdot s^{-2}' , 'm\u00b7s<sup>-2</sup>' ) 144545.45454545456 ( 'kg' , 'kg' ) Because physical quantities have different physical meanings when dividing right by other types of data, we do not set the right dividing method in this API. Comparison operation Quantity.equal(self, other) Quantity.__eq__(self, other) These two methods judge whether two physical quantities are equal. Its meaning is the same as the equality judgment of ordinary types. The two physical quantities are equal only when the q_types of two instances of the class Quantity or its subclasses are equal, under the premise that they are all converted to the same unit, and their value values are also equal. When the parameter other is not an instance of Quantity or its subclasses, these two methods will throw a ValueError exception. When parameter other is an instance of Quantity or its subclasses, but the q_types of the two are not the same, it means that they are not the same type of physical quantity. These two methods will throw a TypeError exception. Using these two methods, we can write the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from quantities import force from quantities import time from quantities import length l1 = length . Length ( 32 , length . LengthType . k_unit ) l2 = length . Length ( 32000 ) l3 = length . Length ( 320 , length . LengthType . k_unit ) t = time . Time ( 32 ) c1 = l1 . equal ( l2 ) c1 = l1 == l2 c2 = l1 . equal ( l3 ) c2 = l1 == l3 print ( c1 ) print ( c2 ) try : l1 . equal ( 32000 ) except ValueError as ex : print ( ex ) try : l1 == 32000 except ValueError as ex : print ( ex ) try : l1 . equal ( t ) except TypeError as ex : print ( ex ) try : l1 == t except TypeError as ex : print ( ex ) The output after running this code snippet is: 1 2 3 4 5 6 True False These two physical quantities can not be compared now ! These two physical quantities can not be compared now ! The two physical quantities are of different types ! The two physical quantities are of different types ! Quantity.le(self, other) Quantity.__le__(self, other) Quantity.ge(self, other) Quantity.__ge__(self, other) Quantity.lt(self, other) Quantity.__lt__(self, other) Quantity.gt(self, other) Quantity.__gt__(self, other) In these four groups of methods, each group has two methods with the same function, which have exactly the same meaning as the ordinary comparison method. The q_types of two instances of the Quantity class or one of its subclasses are equal, and their value values can be compared only when they are converted to the same unit. When the parameter other is not an instance of Quantity or its subclasses, these two methods will throw a ValueError exception. When parameter other is an instance of Quantity or its subclasses, but the q_types of the two are not the same, it means that they are not the same type of physical quantity. These two methods will throw a TypeError exception. According to these four groups of methods, we can write the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from quantities import time from quantities import length l1 = length . Length ( 2 , length . LengthType . k_unit ) l2 = length . Length ( 2001 ) c1 = l2 . gt ( l1 ) c1 = l2 > l1 c2 = l1 . lt ( l2 ) c2 = l1 < l2 c3 = l2 . ge ( l1 ) c3 = l2 >= l1 c4 = l1 . le ( l2 ) c4 = l1 <= l2 t = time . Time ( 2 , time . TimeType . k_unit ) print ( c1 ) print ( c2 ) print ( c3 ) print ( c4 ) try : l2 >= 2000 except ValueError as ex : print ( ex ) try : l2 >= t except TypeError as ex : print ( ex ) The results of this code snippet are as follows: 1 2 3 4 5 6 True True True True These two physical quantities can not be compared now ! The two physical quantities are of different types ! Other methods Quantity.__init__(self, value:float, q_type:QuantityType, unit=None) This is the constructor of the physical quantity. Its first parameter value expresses the specific value of the physical quantity in a specific unit. It is a floating point number. The second parameter q_type is the QuantityType class or its subclasses. It expresses the type of this physical quantity. For example, the physical quantity of length, its type is LengthType . It determines the characteristics of this physical quantity. The third parameter unit expresses the unit of some physical quantity. By default, the SI coherent unit of this type is selected. Under normal circumstances, this constructor is rarely used. We would rather inherit the Quantity class to generate a new subclass for a certain physical quantity, and specify its physical quantity type in the subclass to determine its characteristics. For example, the LengthType class is a subclass of QuantityType , which is the type we designed for the physical quantity of length. At the same time, we will design class Length , which is the subclass of Quantity , to express the physical quantity of length, and directly specify its q_type attribute in the constructor. For details, please refer to [Lenght]. Quantity.to_unit(self, unit) \uff1aThis method can achieve unit conversion, it will return a new Quantity or an instance of its subclass. Quantity and its subclasses are immutable object classes. If the parameter unit does not match the physical quantity type expressed by an instance of Quantity or its subclass, the method will throw a TypeError exception. For example, if an instance of Quantity expresses the length physical quantity, but we pass in the unit of the mass physical quantity type in to_unit , or pass in None, it will throw a TypeError exception. Using this method we can write the following code: 1 2 3 4 5 6 7 from quantities import length l1 = length . Length ( 2 , length . LengthType . k_unit ) l_type = l1 . q_type l2 = l1 . to_unit ( l_type . SI_conherent_unit ) assert l2 . value == 2000 Three only-read properties Quantity.value(self) \uff1aThis is a getter property that expresses the specific value of this physical quantity in the currently selected unit condition. Only using this property and the current_unit property at the same time can fully express a physical quantity. Quantity.q_type(self) \uff1aThis property expresses the type of this physical quantity. Quantity.current_unit \uff1aThis property expresses the currently selected unit of this physical quantity\u3002 API of the QuantityType class QuantityType is a very important class. Based on it, the physical quantity type expressed by the instance of Quantity and its subclasses can be determined, and the available unit of a certain physical quantity type in the Physical Quantity Calculating system can also be determined according to it. Based on it, the system can determine the new physical quantity after the calculation. Because each physical quantity has a unique type, only one instance of QuantityType is required for each physical quantity, and this instance is the class object of QuantityType and its subclasses, which has global uniqueness. Therefore, the programming interfaces we are going to discuss are all class properties and class methods. Available units In Physical Quantity Calculating, the available units of a specific physical quantity can be obtained in QuantityType and its subclasses. They are divided into four categories. QuantityType.pri_unit The first category is the primary unit. This unit is the starting point for designing other units. For example, the primary unit of the length unit is m, and the primary unit of the mass unit is g. QuantityType.SI_conherent_unit The second category is the coherent unit of the SI unit system. Generally, the primary unit of a physical quantity is often the same as its coherent unit, but there are exceptions. For example, in the mass unit, g is its primary unit, which facilitates the design of the entire system. But the coherent unit of its SI unit system is kg. 20 properties such as QuantityType.g_unit The SI unit system design contains 20 prefix units to express the multiples or fractional units of its coherent unit. When the QuantityType was designed, these 20 units were naturally included. Its properties are in the form of prefix followed by _unit. For example, for the length quantity, its coherent unit is m, then its k prefix unit is km, which can be obtained from LengthType.k_unit \u3002 Other non-SI units 1 In Physical Quantity Calculating, in addition to the SI unit system, some non-SI units of physical quantity, such as feet, inches and other units of length quantity, are also partially realized. There are corresponding class attributes in the subclasses of the corresponding QuantityType. For example, the length in feet can be obtained through LengthType.inch. According to the available unit interface of QuantityType, we can write the following code: 1 2 3 4 5 6 from quantities import length l1 = length . Length ( 2 , length . LengthType . k_unit ) l2 = l1 . to_unit ( length . LengthType . inch ) print ( l2 . value ) print ( l2 . current_unit . symbol ()) The results of this code snippet are as follows: 1 2 78740.15748031497 ( 'inch' , 'inch' ) Register new QuantityType subclass QuantityType and its subclasses have a class method register_type . It will register a subclass of QuantityType with the system to let the system know how this type is obtained through arithmetic calculations. Generally, when designing a new QuantityType subclass, you must override this method, but do not modify it during programming. QuantityType.source All QuantityType and its subclasses have a source property. This property points to a dictionary that contains information about all types of physical quantities. Generally, it is only necessary to add new content to the dictionary pointed to by source by overriding its register_type class method when designing a subclass of QuantityType. When programming, never modify the source so that it points to other content, and do not modify the content of the dictionary it points to. For details about the register_type method and the property source , please refer to Add A New Quantity API of the Unit class Unit expresses the unit of physical quantity. It only needs one instance, unlike Quantity, which requires multiple instances to express multiple instances of the same type of physical quantity. In the Pyhton programming language, a class is also an object, and the class object is unique in the global scope. Therefore, we use class objects to express various units of various types of physical quantities. Therefore, in Physical Quantity Calculating, the methods of Unit and its subclasses are all class methods. These methods are divided into three categories, one is used for unit conversion, the another is used for writing expression, and the last is q_type property. Unit conversion It is only necessary to design two unit conversion methods for each unit, one is used for calculation of conversion from this unit to another unit, and the other is used for calculation of conversion from another unit to this unit. There are these two methods to ensure that the unit can be freely converted between the same type of physical unit. For details, see the pattern of Figure 3.3 in UML Diagrams for Chapter 3 of Analysis Patterns \u3002 The two specific methods are as follows: Unit.from_pri_unit(cls, value) Unit.to_pri_unit(cls, value) The two specific methods are as follows. Their parameter value refers to the specific digital value in the current unit. For example, the current unit of the physical quantity of length is m, and its numerical value is 1000. It needs to be converted to a unit such as km. Such problems are often dealt with in Quantity.to_unit, the code is as follows: 1 2 3 4 5 6 7 8 9 class Quantity ...... def to_unit ( self , unit : Unit ): if unit not in self . q_type . __dict__ . values () or unit == None : raise TypeError ( 'The unit is not for this physical qunatity!' ) else : to_pri_value = self . current_unit . to_pri_unit ( self . __value ) value = unit . from_pri_unit ( to_pri_value ) return Quantity ( value , self . q_type , unit ) The meaning of pri_unit has been explained in the design of QuantityType, which can be seen in detail . writing expression There are usually three ways to write and express units in the SI unit system and other units that are not in the SI unit system. The first is to directly use the symbol of the unit to express the unit. The second is to use the power product of the basic unit of the SI unit system to express. The third is to use the power product of the basic unit of the SI unit system and the derived unit with a specific name to express. Writing may occur in Latex documents or html documents, and the way of expression is different. To this end, Unit provides a total of three methods, each of which can return the content expressed in the two documents. they are, respectively: Unit.symbol(cls) Unit.express_by_SI_base(cls) Unit.express_by_SI(cls) Each method returns a tuple, which contains latex writing and html writing strings. The following code illustrates this: 1 2 3 4 5 6 7 8 9 10 11 from quantities import length from quantities import acceleration from quantities import energy l = length . Length ( 2 ) a = acceleration . Acceleration ( 3 ) e = energy . Energy ( 5 ) print ( l . current_unit . symbol ()) print ( a . current_unit . express_by_SI_base ()) print ( e . current_unit . express_by_SI ()) The results of this code snippet are as follows: 1 2 3 ( 'm' , 'm' ) ( 'm \\\\ cdot s^{-2}' , 'm\u00b7s<sup>-2</sup>' ) ( 'N \\\\ cdot m' , 'N\u00b7m' ) Unit.q_type class property This property returns a class object of a subclass of QuantityType. It indicates that this unit can only be used for the physical quantity specified by q_type , and is a usable unit of this physical quantity type. The system has added non-SI units for quantity types such as length , area , volume , mass , energy , plane_angle and time . \u21a9","title":"API Reference"},{"location":"API%20Reference.html#api-reference","text":"The API of Physical Quantity Calculating mainly includes the arithmetic and comparison of Quantity class, as well as the operation of transforming units such as to_unit . We also need to pay special attention to the register method of QuantityType. The methods of the Unit class are also very interesting, involving unit conversion and unit writing expression.","title":"API Reference"},{"location":"API%20Reference.html#api-of-the-quantity-class","text":"Quantity is the main class for programming to operate, and it is the base class for all physical quantities\u3002It has arithmetic operations and comparison operations, in particular it also has conversion unit operations, these operations realize the calculation of the number and the conversion of units. It is an operation that is often used in programming.","title":"API of the Quantity class"},{"location":"API%20Reference.html#arithmetic-operations","text":"Quantity.add(self, other) :\u3000This method provides operation of the same type of physical quantity. If the parameter other is not of the same type, a ValueError exception will be thrown.\u3000The method returns a physical quantity whose type is the same as the type of the physical quantity participating in the operation. The unit is the SI coherent unit of the physical quantity. Quantity.substract(self, other) :\u3000This method provides operation of the same type of physical quantity. If the parameter other is not of the same type, a ValueError exception will be thrown. The method returns a physical quantity whose type is the same as the type of the physical quantity participating in the operation. The unit is the SI coherent unit of the physical quantity. Quantity.multiply(self, other) :\u3000This method returns the product of the physical quantity and other types of parameters. The system will Can return diversified results. If the parameter other is of type float or int, the return result is a physical quantity whose type is the same as this physical quantity, and the unit is the same as this physical quantity, except that its value is equal to the result of multiplying the value of this physical quantity with other. When other is an ohter non-Quantity type, a ValueError exception will be thrown When ohter is a subtype Identity of Quantity, or when the physical quantity is Identity, the returned result is the same as the first case. If other is of type Quantity or its subtypes, but the system cannot determine the type after multiplication, it will throw TypeError exception. The following is an example of the application. Please carefully observe the running results of this example program. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 from quantities import length from quantities import identity from quantities import time from quantities import velocity l = length . Length ( 32 , unit = length . LengthType . mu_unit ) i = identity . Identity ( 24 ) v = velocity . Velocity ( 32 ) t = time . Time ( 12 ) l1 = l . multiply ( 24 ) l2 = l . multiply ( i ) l3 = v . multiply ( t ) print ( l1 . value ) print ( l1 . current_unit . symbol ()) print ( l2 . value ) print ( l2 . current_unit . symbol ()) print ( l3 . value ) print ( l3 . current_unit . symbol ()) try : l . multiply ( v ) except TypeError : print ( \"A TypeError is thrown!\" ) The running results of the program are as follows: 1 2 3 4 5 6 7 768 ( ' \\\\ mu m' , '\u03bcm' ) 0.000768 ( 'm' , 'm' ) 384.0 ( 'm' , 'm' ) A TypeError is thrown ! l1 is an result of the length quantity multiplied by an integer, so it is still a length quantity, and its current unit is still \u03bcm. And l2 is an result of the length quantity multiplied by an instance of the Identity quantity, the it is still the length quantity, but its unit is the SI coherent unit of this quantity. We provide an interface for multiplying integers or floating-point numbers, but we still recommend using a physical quantity to multiply an instance of Identity, so that the physical concept is clearer. Quantity.__mul__(self, other) Quantity.__rmul__(self, other) These two functions are magic methods of the python class, which also express multiplication, and the __rmul__ () method expresses the concept of right multiplication. With these two functions, we can write the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from quantities import length from quantities import identity from quantities import time from quantities import velocity l = length . Length ( 32 , unit = length . LengthType . mu_unit ) i = identity . Identity ( 24 ) v = velocity . Velocity ( 32 ) t = time . Time ( 12 ) l1 = l . multiply ( 24 ) l2 = l . multiply ( i ) l3 = v . multiply ( t ) l1 = 24 * l l1 = l * 24 l2 = i * l l2 = l * i l3 = v * t l3 = t * v try : v * l except TypeError : pass try : l * v except TypeError : pass The running result is consistent with the running result of the sample code of the Quantity.multiply method. Quantitiy.divide(self, other) Quantity.__truediv__(self, other) The functions of these two functions are the same, and both express the division of physical quantities. According to the different types of the parameter ohter, the system will return different results. If the parameter other is of type float or int, the return result is a physical quantity whose type is the same as this physical quantity, and the unit is the same as this physical quantity, except that its value is equal to the result of dividing the value of this physical quantity with other. When other is an ohter non-Quantity type, a ValueError exception will be thrown When ohter is a subtype Identity of Quantity, or when the physical quantity is Identity, the returned result is the same as the first case. If other is of type Quantity or its subtypes, but the system cannot determine the type after division, it will throw TypeError exception. Based on these characteristics, we can write the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from quantities import force from quantities import time from quantities import length f = force . Force ( 53 , force . ForceType . k_unit ) t = time . Time ( 5 , time . TimeType . minute ) l = length . Length ( 33 , length . LengthType . k_unit ) v = l . divide ( t ) v = l / t a = v . divide ( t ) a = v / t m = f . divide ( a ) m = f / a print ( v . value ) print ( v . current_unit . express_by_SI_base ()) print ( a . value ) print ( a . current_unit . express_by_SI_base ()) print ( m . value ) print ( m . current_unit . symbol ()) The results of this code snippet are as follows: 1 2 3 4 5 6 110.0 ( 'm/s' , 'm/s' ) 0.36666666666666664 ( 'm \\\\ cdot s^{-2}' , 'm\u00b7s<sup>-2</sup>' ) 144545.45454545456 ( 'kg' , 'kg' ) Because physical quantities have different physical meanings when dividing right by other types of data, we do not set the right dividing method in this API.","title":"Arithmetic operations"},{"location":"API%20Reference.html#comparison-operation","text":"Quantity.equal(self, other) Quantity.__eq__(self, other) These two methods judge whether two physical quantities are equal. Its meaning is the same as the equality judgment of ordinary types. The two physical quantities are equal only when the q_types of two instances of the class Quantity or its subclasses are equal, under the premise that they are all converted to the same unit, and their value values are also equal. When the parameter other is not an instance of Quantity or its subclasses, these two methods will throw a ValueError exception. When parameter other is an instance of Quantity or its subclasses, but the q_types of the two are not the same, it means that they are not the same type of physical quantity. These two methods will throw a TypeError exception. Using these two methods, we can write the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 from quantities import force from quantities import time from quantities import length l1 = length . Length ( 32 , length . LengthType . k_unit ) l2 = length . Length ( 32000 ) l3 = length . Length ( 320 , length . LengthType . k_unit ) t = time . Time ( 32 ) c1 = l1 . equal ( l2 ) c1 = l1 == l2 c2 = l1 . equal ( l3 ) c2 = l1 == l3 print ( c1 ) print ( c2 ) try : l1 . equal ( 32000 ) except ValueError as ex : print ( ex ) try : l1 == 32000 except ValueError as ex : print ( ex ) try : l1 . equal ( t ) except TypeError as ex : print ( ex ) try : l1 == t except TypeError as ex : print ( ex ) The output after running this code snippet is: 1 2 3 4 5 6 True False These two physical quantities can not be compared now ! These two physical quantities can not be compared now ! The two physical quantities are of different types ! The two physical quantities are of different types ! Quantity.le(self, other) Quantity.__le__(self, other) Quantity.ge(self, other) Quantity.__ge__(self, other) Quantity.lt(self, other) Quantity.__lt__(self, other) Quantity.gt(self, other) Quantity.__gt__(self, other) In these four groups of methods, each group has two methods with the same function, which have exactly the same meaning as the ordinary comparison method. The q_types of two instances of the Quantity class or one of its subclasses are equal, and their value values can be compared only when they are converted to the same unit. When the parameter other is not an instance of Quantity or its subclasses, these two methods will throw a ValueError exception. When parameter other is an instance of Quantity or its subclasses, but the q_types of the two are not the same, it means that they are not the same type of physical quantity. These two methods will throw a TypeError exception. According to these four groups of methods, we can write the following code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from quantities import time from quantities import length l1 = length . Length ( 2 , length . LengthType . k_unit ) l2 = length . Length ( 2001 ) c1 = l2 . gt ( l1 ) c1 = l2 > l1 c2 = l1 . lt ( l2 ) c2 = l1 < l2 c3 = l2 . ge ( l1 ) c3 = l2 >= l1 c4 = l1 . le ( l2 ) c4 = l1 <= l2 t = time . Time ( 2 , time . TimeType . k_unit ) print ( c1 ) print ( c2 ) print ( c3 ) print ( c4 ) try : l2 >= 2000 except ValueError as ex : print ( ex ) try : l2 >= t except TypeError as ex : print ( ex ) The results of this code snippet are as follows: 1 2 3 4 5 6 True True True True These two physical quantities can not be compared now ! The two physical quantities are of different types !","title":"Comparison operation"},{"location":"API%20Reference.html#other-methods","text":"Quantity.__init__(self, value:float, q_type:QuantityType, unit=None) This is the constructor of the physical quantity. Its first parameter value expresses the specific value of the physical quantity in a specific unit. It is a floating point number. The second parameter q_type is the QuantityType class or its subclasses. It expresses the type of this physical quantity. For example, the physical quantity of length, its type is LengthType . It determines the characteristics of this physical quantity. The third parameter unit expresses the unit of some physical quantity. By default, the SI coherent unit of this type is selected. Under normal circumstances, this constructor is rarely used. We would rather inherit the Quantity class to generate a new subclass for a certain physical quantity, and specify its physical quantity type in the subclass to determine its characteristics. For example, the LengthType class is a subclass of QuantityType , which is the type we designed for the physical quantity of length. At the same time, we will design class Length , which is the subclass of Quantity , to express the physical quantity of length, and directly specify its q_type attribute in the constructor. For details, please refer to [Lenght]. Quantity.to_unit(self, unit) \uff1aThis method can achieve unit conversion, it will return a new Quantity or an instance of its subclass. Quantity and its subclasses are immutable object classes. If the parameter unit does not match the physical quantity type expressed by an instance of Quantity or its subclass, the method will throw a TypeError exception. For example, if an instance of Quantity expresses the length physical quantity, but we pass in the unit of the mass physical quantity type in to_unit , or pass in None, it will throw a TypeError exception. Using this method we can write the following code: 1 2 3 4 5 6 7 from quantities import length l1 = length . Length ( 2 , length . LengthType . k_unit ) l_type = l1 . q_type l2 = l1 . to_unit ( l_type . SI_conherent_unit ) assert l2 . value == 2000","title":"Other methods"},{"location":"API%20Reference.html#three-only-read-properties","text":"Quantity.value(self) \uff1aThis is a getter property that expresses the specific value of this physical quantity in the currently selected unit condition. Only using this property and the current_unit property at the same time can fully express a physical quantity. Quantity.q_type(self) \uff1aThis property expresses the type of this physical quantity. Quantity.current_unit \uff1aThis property expresses the currently selected unit of this physical quantity\u3002","title":"Three only-read properties"},{"location":"API%20Reference.html#api-of-the-quantitytype-class","text":"QuantityType is a very important class. Based on it, the physical quantity type expressed by the instance of Quantity and its subclasses can be determined, and the available unit of a certain physical quantity type in the Physical Quantity Calculating system can also be determined according to it. Based on it, the system can determine the new physical quantity after the calculation. Because each physical quantity has a unique type, only one instance of QuantityType is required for each physical quantity, and this instance is the class object of QuantityType and its subclasses, which has global uniqueness. Therefore, the programming interfaces we are going to discuss are all class properties and class methods.","title":"API of the QuantityType class"},{"location":"API%20Reference.html#available-units","text":"In Physical Quantity Calculating, the available units of a specific physical quantity can be obtained in QuantityType and its subclasses. They are divided into four categories. QuantityType.pri_unit The first category is the primary unit. This unit is the starting point for designing other units. For example, the primary unit of the length unit is m, and the primary unit of the mass unit is g. QuantityType.SI_conherent_unit The second category is the coherent unit of the SI unit system. Generally, the primary unit of a physical quantity is often the same as its coherent unit, but there are exceptions. For example, in the mass unit, g is its primary unit, which facilitates the design of the entire system. But the coherent unit of its SI unit system is kg. 20 properties such as QuantityType.g_unit The SI unit system design contains 20 prefix units to express the multiples or fractional units of its coherent unit. When the QuantityType was designed, these 20 units were naturally included. Its properties are in the form of prefix followed by _unit. For example, for the length quantity, its coherent unit is m, then its k prefix unit is km, which can be obtained from LengthType.k_unit \u3002 Other non-SI units 1 In Physical Quantity Calculating, in addition to the SI unit system, some non-SI units of physical quantity, such as feet, inches and other units of length quantity, are also partially realized. There are corresponding class attributes in the subclasses of the corresponding QuantityType. For example, the length in feet can be obtained through LengthType.inch. According to the available unit interface of QuantityType, we can write the following code: 1 2 3 4 5 6 from quantities import length l1 = length . Length ( 2 , length . LengthType . k_unit ) l2 = l1 . to_unit ( length . LengthType . inch ) print ( l2 . value ) print ( l2 . current_unit . symbol ()) The results of this code snippet are as follows: 1 2 78740.15748031497 ( 'inch' , 'inch' )","title":"Available units"},{"location":"API%20Reference.html#register-new-quantitytype-subclass","text":"QuantityType and its subclasses have a class method register_type . It will register a subclass of QuantityType with the system to let the system know how this type is obtained through arithmetic calculations. Generally, when designing a new QuantityType subclass, you must override this method, but do not modify it during programming.","title":"Register new QuantityType subclass"},{"location":"API%20Reference.html#quantitytypesource","text":"All QuantityType and its subclasses have a source property. This property points to a dictionary that contains information about all types of physical quantities. Generally, it is only necessary to add new content to the dictionary pointed to by source by overriding its register_type class method when designing a subclass of QuantityType. When programming, never modify the source so that it points to other content, and do not modify the content of the dictionary it points to. For details about the register_type method and the property source , please refer to Add A New Quantity","title":"QuantityType.source"},{"location":"API%20Reference.html#api-of-the-unit-class","text":"Unit expresses the unit of physical quantity. It only needs one instance, unlike Quantity, which requires multiple instances to express multiple instances of the same type of physical quantity. In the Pyhton programming language, a class is also an object, and the class object is unique in the global scope. Therefore, we use class objects to express various units of various types of physical quantities. Therefore, in Physical Quantity Calculating, the methods of Unit and its subclasses are all class methods. These methods are divided into three categories, one is used for unit conversion, the another is used for writing expression, and the last is q_type property.","title":"API of the Unit class"},{"location":"API%20Reference.html#unit-conversion","text":"It is only necessary to design two unit conversion methods for each unit, one is used for calculation of conversion from this unit to another unit, and the other is used for calculation of conversion from another unit to this unit. There are these two methods to ensure that the unit can be freely converted between the same type of physical unit. For details, see the pattern of Figure 3.3 in UML Diagrams for Chapter 3 of Analysis Patterns \u3002 The two specific methods are as follows: Unit.from_pri_unit(cls, value) Unit.to_pri_unit(cls, value) The two specific methods are as follows. Their parameter value refers to the specific digital value in the current unit. For example, the current unit of the physical quantity of length is m, and its numerical value is 1000. It needs to be converted to a unit such as km. Such problems are often dealt with in Quantity.to_unit, the code is as follows: 1 2 3 4 5 6 7 8 9 class Quantity ...... def to_unit ( self , unit : Unit ): if unit not in self . q_type . __dict__ . values () or unit == None : raise TypeError ( 'The unit is not for this physical qunatity!' ) else : to_pri_value = self . current_unit . to_pri_unit ( self . __value ) value = unit . from_pri_unit ( to_pri_value ) return Quantity ( value , self . q_type , unit ) The meaning of pri_unit has been explained in the design of QuantityType, which can be seen in detail .","title":"Unit conversion"},{"location":"API%20Reference.html#writing-expression","text":"There are usually three ways to write and express units in the SI unit system and other units that are not in the SI unit system. The first is to directly use the symbol of the unit to express the unit. The second is to use the power product of the basic unit of the SI unit system to express. The third is to use the power product of the basic unit of the SI unit system and the derived unit with a specific name to express. Writing may occur in Latex documents or html documents, and the way of expression is different. To this end, Unit provides a total of three methods, each of which can return the content expressed in the two documents. they are, respectively: Unit.symbol(cls) Unit.express_by_SI_base(cls) Unit.express_by_SI(cls) Each method returns a tuple, which contains latex writing and html writing strings. The following code illustrates this: 1 2 3 4 5 6 7 8 9 10 11 from quantities import length from quantities import acceleration from quantities import energy l = length . Length ( 2 ) a = acceleration . Acceleration ( 3 ) e = energy . Energy ( 5 ) print ( l . current_unit . symbol ()) print ( a . current_unit . express_by_SI_base ()) print ( e . current_unit . express_by_SI ()) The results of this code snippet are as follows: 1 2 3 ( 'm' , 'm' ) ( 'm \\\\ cdot s^{-2}' , 'm\u00b7s<sup>-2</sup>' ) ( 'N \\\\ cdot m' , 'N\u00b7m' )","title":"writing expression"},{"location":"API%20Reference.html#unitq_type-class-property","text":"This property returns a class object of a subclass of QuantityType. It indicates that this unit can only be used for the physical quantity specified by q_type , and is a usable unit of this physical quantity type. The system has added non-SI units for quantity types such as length , area , volume , mass , energy , plane_angle and time . \u21a9","title":"Unit.q_type class property"},{"location":"LICENSE.html","text":"LICENSE MIT License Copyright (c) 2021 chenmich Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"LICENSE.html#license","text":"MIT License Copyright (c) 2021 chenmich Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"LICENSE"},{"location":"Quantity_Model.html","text":"Quantity Model In engineering and scientific calculations, people are often confused because of the dizzying number and units of physics. The reason is that we first consider unit conversion rather than considering the conversion relationship between quantities before calculating. For example, when we calculate the force of an object in motion, Newton's second law should be used. We wrote the formula first \\(a=\\frac{m\\times l}{t^{2}}\\) . After that, we will examine the formula of each physical quantity(m, l, t), and then do the unit conversion. When there are many such calculationsthe and formula is complicated, you will often get lost here and lose the opportunity to understand the results of the calculations. The reason is that we pay too much attention to the conversion of units and neglect the relationship between the various physical quantities in the calculation process, and we confuse the unit of measurement, the dimension and the physical nature of the physical quantity itself, so we often Lost in this calculation. Then people will definitely ask a question, that is, what is the nature of physical quantity, what is the dimension, and what is the unit of physical quantity, and so on. physical quantity I personally believe that in the physical world, every thing has its attributes. We look for these attributes and their relationships, and we can understand the characteristics of things based on these attributes and their relationships. No matter how we measure these properties, it always exists. For example, when an object rotates, it must have speed, acceleration, and displacement, and it is also related to time. Therefore, when studying the motion of an object, its attributes include displacement, velocity, and acceleration. Of course, time is also one of the key attributes of the motion of an object. These attributes and relationships exist in essence, and their existence has nothing to do with our understanding, and it has nothing to do with how we measure them. unit of measurement We can always predict other attributes of certain things in the physical world by measuring certain physical quantities and based on correlations. For example, according to Newton's second law of motion of an object, if we measure its mass and force, we can calculate its acceleration. If no longer based on the relationship between acceleration, displacement and time, we can also predict where the object will arrive in how long. Therefore, the measurement of physical quantity is a necessary means for science and engineering to understand the world and use the laws of nature. The essence of measurement is comparison. For example, when we measure the length of an object, we always compare the fixed length of another object with the length of the object being measured. In daily life, we use a ruler to measure the length of cloth, that is, the length of the ruler is 1, to see how many rulers the length of the cloth has. The magnitude from compared value is the of the measured physical quantity of cloth length, and its unit is one ruler. The size of the ruler can be arbitrary, as long as the same ruler is used every time to ensure that the results of each measurement are comparable. The length of a person's elbow has been used as a ruler in history. Essentially, each type of physical quantity should have its own unit of measurement, and the attributes of these units of measurement are determined by the characteristics of the type of physical quantity. For example, the physical quantity of length type must have the characteristic of length in its unit of measurement, and the unit of measurement of speed cannot be used to measure length. Therefore, each quantity type determines its unit of measurement attributes. But what numberical value can be used as the measurement unit of the physical quantity is arbitrarily chosen by people. One type of physical quantity requires one type of measurement unit. However, there are many things in our world, and there are more physical quantities that need to be measured. If the unit of measurement is defined for each type of physical quantity, the workload is extremely huge and it is a difficult task to complete. Therefore, people often choose a few from a large number of physical quantities, and define units specifically for them, which are called basic units. The units of other physical quantities are directly derived from these basic units, and the basis for the derivation is the basic relationship between these physical quantities. For example, the unit of measurement for length is meters, and the relationship between area and length is length multiplied by length, so the unit is also meters by meters, that is, square meters. By setting the basic unit, the derived unit is generated from the basic unit, and then a new derived unit is generated from the basic unit and the derived unit, so that the unit of measurement can be conveniently defined for the numerous quantities in the world we are studying. It is worth noting that what kind of physical quantity is chosen as the basic unit is also a choice made by humans, and it will not change the equal relationship between physical quantities. From the point of view of scientific principles, there is no basic physical quantity and derived physical quantity in physical quantity, so there is no high or low unit of measurement. In the unit system, physical quantities are divided into basic physical quantities and derived physical quantities, and measurement units are divided into basic measurement units and derived measurement units, which are purely determined by humans for the convenience of defining the specific value of the measurement unit. This should not make us mistakenly think that understanding the unit of measurement and the basic unit of measurement is more important than understanding the nature of physical quantities. In the process of calculating physical quantities, people use some common quantities as the basis. According to the relationship between physical quantities, it is determined that certain quantities can be derived from other quantities. The purpose is also to simplify calculations and select units. Starting from the relationship between the physical world, people found that the two sides of the equal sign of the equation of the laws of nature, the power exponents of their physical quantities should be equal. From here, people also developed a set of dimensional analysis methods to analyze the laws of the physical world. The core is to use several selected dimensions as the basis, and through mathematical transformations, the relationship between quantities can be expressed more simply and clearly. But from the physical essence, dimensions are unnecessary artifacts. Especially in the calculations between physical quantities that have a clear relationship, the dimensions are often confusing. Without going through the dimension, as long as we clearly know what type of physical quantity will be obtained in each step of the calculation, the choice of the unit is also very simple, and it has nothing to do with whether the dimension is used or not. When the derived unit is used in the SI unit system, because the expression of the unit is related to the basic unit, the dimension corresponding to the basic unit is specified, and its essence is for the convenience of narrative. It has nothing to do with whether dimensions are essentially required in physics. Below we will discuss the SI unit system. In the SI unit system, most units are derived from a few units. Due to the complexity of the physical world and the complexity of calculations, it is inevitable that many units of physical quantities will be the same. For example, the units of energy, work and heat are the same, and the units of heat capacity and entropy, specific heat capacity and specific heat entropy are also the same. Therefore, although each physical quantity has its own unit, a certain unit does not only correspond to one physical quantity. When calculating, it is not advisable to calculate the unit of the result physical quantity first, and then determine the type of the physical quantity. In addition, the unit of energy is N\u00b7m, and the unit of torque is also N\u00b7m, but they are two completely different types of physical quantities, which are the same as parameters, work and heat units, but are different from heat capacity and entropy. There are similarities and differences between specific heat capacity and specific heat entropy. These domain characteristics require us to be very careful when programming calculations. SI unit System Although the size of the unit can be chosen arbitrarily, it is also possible to choose any thing as the unit of measurement. However, in order to ensure the stability of the measurement unit, people continue to improve this choice, making the reproducibility of the measurement unit more and more guaranteed. In the long-term process, people have gradually determined a set of choices and formed various levels of measurement standards to ensure the stability and comparability of people's measurement results in scientific research, engineering practice, and daily life. The SI unit system is one of these unit systems. The SI unit system first stipulates that seven physical quantities are their basic quantities, and their units are basic units. Then, according to the principle of simplicity, use the relationship between physical quantities to derive the units of other physical quantities, which is part of the derived units. Using the basic unit and these derived units, and further deriving other physical quantity units, you can define as many physical quantity units as possible. An outstanding feature of the SI unit system is that all units have a coherent unit, and this unit is selected for calculation, so that when people use the laws of physics to calculate, no additional unit conversion coefficients will be added to the physics formula. For example, when choosing the meter, second, kg in the SI unit value as the unit, and using Newton\u2019s second law to calculate the force on an object, its formula is \\(F=ma=m\\times l/t^{2}\\) , There are no coefficients due to unit conversion. This brings a lot of cheapness to our calculations. Before calculating, we can convert the unit of measurement of each physical quantity to coherent unit in advance. The measurement unit of the final result is also the coherent unit of the calculated physical quantity. Using this method to calculate physical quantities allows us to pay more attention to the nature of calculations and the physical meaning of calculations in the calculation process, without getting lost in dazzling measurement units. The Physical Quantity Calculating class library In physical quantity calculating class library, the unit of measurement that can be processed is the SI measurement unit, including the non-SI measurement unit used by SI. It also provides a conversion interface between other commonly used units and SI measurement units. More importantly, the use of the physical quantity calculation class library can force us to clearly know the type of the result quantity of each step in the process of programming calculation, and select the corresponding measurement unit on this basis to ensure that the type of the calculation result is the accuracy of the unit.","title":"Quantity Model"},{"location":"Quantity_Model.html#quantity-model","text":"In engineering and scientific calculations, people are often confused because of the dizzying number and units of physics. The reason is that we first consider unit conversion rather than considering the conversion relationship between quantities before calculating. For example, when we calculate the force of an object in motion, Newton's second law should be used. We wrote the formula first \\(a=\\frac{m\\times l}{t^{2}}\\) . After that, we will examine the formula of each physical quantity(m, l, t), and then do the unit conversion. When there are many such calculationsthe and formula is complicated, you will often get lost here and lose the opportunity to understand the results of the calculations. The reason is that we pay too much attention to the conversion of units and neglect the relationship between the various physical quantities in the calculation process, and we confuse the unit of measurement, the dimension and the physical nature of the physical quantity itself, so we often Lost in this calculation. Then people will definitely ask a question, that is, what is the nature of physical quantity, what is the dimension, and what is the unit of physical quantity, and so on.","title":"Quantity Model"},{"location":"Quantity_Model.html#physical-quantity","text":"I personally believe that in the physical world, every thing has its attributes. We look for these attributes and their relationships, and we can understand the characteristics of things based on these attributes and their relationships. No matter how we measure these properties, it always exists. For example, when an object rotates, it must have speed, acceleration, and displacement, and it is also related to time. Therefore, when studying the motion of an object, its attributes include displacement, velocity, and acceleration. Of course, time is also one of the key attributes of the motion of an object. These attributes and relationships exist in essence, and their existence has nothing to do with our understanding, and it has nothing to do with how we measure them.","title":"physical quantity"},{"location":"Quantity_Model.html#unit-of-measurement","text":"We can always predict other attributes of certain things in the physical world by measuring certain physical quantities and based on correlations. For example, according to Newton's second law of motion of an object, if we measure its mass and force, we can calculate its acceleration. If no longer based on the relationship between acceleration, displacement and time, we can also predict where the object will arrive in how long. Therefore, the measurement of physical quantity is a necessary means for science and engineering to understand the world and use the laws of nature. The essence of measurement is comparison. For example, when we measure the length of an object, we always compare the fixed length of another object with the length of the object being measured. In daily life, we use a ruler to measure the length of cloth, that is, the length of the ruler is 1, to see how many rulers the length of the cloth has. The magnitude from compared value is the of the measured physical quantity of cloth length, and its unit is one ruler. The size of the ruler can be arbitrary, as long as the same ruler is used every time to ensure that the results of each measurement are comparable. The length of a person's elbow has been used as a ruler in history. Essentially, each type of physical quantity should have its own unit of measurement, and the attributes of these units of measurement are determined by the characteristics of the type of physical quantity. For example, the physical quantity of length type must have the characteristic of length in its unit of measurement, and the unit of measurement of speed cannot be used to measure length. Therefore, each quantity type determines its unit of measurement attributes. But what numberical value can be used as the measurement unit of the physical quantity is arbitrarily chosen by people. One type of physical quantity requires one type of measurement unit. However, there are many things in our world, and there are more physical quantities that need to be measured. If the unit of measurement is defined for each type of physical quantity, the workload is extremely huge and it is a difficult task to complete. Therefore, people often choose a few from a large number of physical quantities, and define units specifically for them, which are called basic units. The units of other physical quantities are directly derived from these basic units, and the basis for the derivation is the basic relationship between these physical quantities. For example, the unit of measurement for length is meters, and the relationship between area and length is length multiplied by length, so the unit is also meters by meters, that is, square meters. By setting the basic unit, the derived unit is generated from the basic unit, and then a new derived unit is generated from the basic unit and the derived unit, so that the unit of measurement can be conveniently defined for the numerous quantities in the world we are studying. It is worth noting that what kind of physical quantity is chosen as the basic unit is also a choice made by humans, and it will not change the equal relationship between physical quantities. From the point of view of scientific principles, there is no basic physical quantity and derived physical quantity in physical quantity, so there is no high or low unit of measurement. In the unit system, physical quantities are divided into basic physical quantities and derived physical quantities, and measurement units are divided into basic measurement units and derived measurement units, which are purely determined by humans for the convenience of defining the specific value of the measurement unit. This should not make us mistakenly think that understanding the unit of measurement and the basic unit of measurement is more important than understanding the nature of physical quantities. In the process of calculating physical quantities, people use some common quantities as the basis. According to the relationship between physical quantities, it is determined that certain quantities can be derived from other quantities. The purpose is also to simplify calculations and select units. Starting from the relationship between the physical world, people found that the two sides of the equal sign of the equation of the laws of nature, the power exponents of their physical quantities should be equal. From here, people also developed a set of dimensional analysis methods to analyze the laws of the physical world. The core is to use several selected dimensions as the basis, and through mathematical transformations, the relationship between quantities can be expressed more simply and clearly. But from the physical essence, dimensions are unnecessary artifacts. Especially in the calculations between physical quantities that have a clear relationship, the dimensions are often confusing. Without going through the dimension, as long as we clearly know what type of physical quantity will be obtained in each step of the calculation, the choice of the unit is also very simple, and it has nothing to do with whether the dimension is used or not. When the derived unit is used in the SI unit system, because the expression of the unit is related to the basic unit, the dimension corresponding to the basic unit is specified, and its essence is for the convenience of narrative. It has nothing to do with whether dimensions are essentially required in physics. Below we will discuss the SI unit system. In the SI unit system, most units are derived from a few units. Due to the complexity of the physical world and the complexity of calculations, it is inevitable that many units of physical quantities will be the same. For example, the units of energy, work and heat are the same, and the units of heat capacity and entropy, specific heat capacity and specific heat entropy are also the same. Therefore, although each physical quantity has its own unit, a certain unit does not only correspond to one physical quantity. When calculating, it is not advisable to calculate the unit of the result physical quantity first, and then determine the type of the physical quantity. In addition, the unit of energy is N\u00b7m, and the unit of torque is also N\u00b7m, but they are two completely different types of physical quantities, which are the same as parameters, work and heat units, but are different from heat capacity and entropy. There are similarities and differences between specific heat capacity and specific heat entropy. These domain characteristics require us to be very careful when programming calculations.","title":"unit of measurement"},{"location":"Quantity_Model.html#si-unit-system","text":"Although the size of the unit can be chosen arbitrarily, it is also possible to choose any thing as the unit of measurement. However, in order to ensure the stability of the measurement unit, people continue to improve this choice, making the reproducibility of the measurement unit more and more guaranteed. In the long-term process, people have gradually determined a set of choices and formed various levels of measurement standards to ensure the stability and comparability of people's measurement results in scientific research, engineering practice, and daily life. The SI unit system is one of these unit systems. The SI unit system first stipulates that seven physical quantities are their basic quantities, and their units are basic units. Then, according to the principle of simplicity, use the relationship between physical quantities to derive the units of other physical quantities, which is part of the derived units. Using the basic unit and these derived units, and further deriving other physical quantity units, you can define as many physical quantity units as possible. An outstanding feature of the SI unit system is that all units have a coherent unit, and this unit is selected for calculation, so that when people use the laws of physics to calculate, no additional unit conversion coefficients will be added to the physics formula. For example, when choosing the meter, second, kg in the SI unit value as the unit, and using Newton\u2019s second law to calculate the force on an object, its formula is \\(F=ma=m\\times l/t^{2}\\) , There are no coefficients due to unit conversion. This brings a lot of cheapness to our calculations. Before calculating, we can convert the unit of measurement of each physical quantity to coherent unit in advance. The measurement unit of the final result is also the coherent unit of the calculated physical quantity. Using this method to calculate physical quantities allows us to pay more attention to the nature of calculations and the physical meaning of calculations in the calculation process, without getting lost in dazzling measurement units.","title":"SI unit System"},{"location":"Quantity_Model.html#the-physical-quantity-calculating-class-library","text":"In physical quantity calculating class library, the unit of measurement that can be processed is the SI measurement unit, including the non-SI measurement unit used by SI. It also provides a conversion interface between other commonly used units and SI measurement units. More importantly, the use of the physical quantity calculation class library can force us to clearly know the type of the result quantity of each step in the process of programming calculation, and select the corresponding measurement unit on this basis to ensure that the type of the calculation result is the accuracy of the unit.","title":"The Physical Quantity Calculating class library"},{"location":"Quickstart.html","text":"Install","title":"Quickstart"},{"location":"Quickstart.html#install","text":"","title":"Install"},{"location":"Usage.html","text":"Usage Physical quantity modeling Users always perform arithmetic operations such as addition, subtraction, multiplication, and division for physical quantities. These operations are the same, so the interfaces of their physical quantity objects are also the same. For this purpose, a class Quantity is used to express the physical quantity. It provides users with a general arithmetic operation interface, and also provides users with an interface to access this physical quantity type. Of course, it also provides operations for setting and obtaining the current unit of measurement. Use the quantity type class to distinguish the type of physical quantity, for example, use class LengthType as the type of quantity object for length quantity. The quantity type is responsible for generating the corresponding SI unit, checking the legality of addition, subtraction, multiplication and division between two objects, generating a new quantity, and responsible for the unit conversion of the quantity. Each physical quantity has its own unit of measurement. Use class Unit to express these units. Each type of physical quantity has its own set of units. These units are automatically created when creating the class of their physical quantity type, and can be selected by the user according to the corresponding type class. create a quantity instance It is very simple to create an instance of a physical quantity, the following is a code example: 1 2 3 4 import quantities as pq q_type = pq . LengthType current_u = q_type . G_unit l = pq . Quantity ( 22 , q_type , current_u ) If you use the default SI coherent unit, you do not need to give the unit to the constructor. 1 2 3 import quantities as pq q_type = pq . LengthType l = pq . Quantity ( 22 , q_type ) The unit of the quantity object of this length type is meter. If you want to convert to other units, such as kilometers, the code can be written as: 1 l1 = l . to_unit ( q_type . k_unit ) Set the unit of the quantity by the quantity type, such as LengthType, to ensure the corresponding relationship between the quantity and the unit. For ease of use, Physical Quantity calculating has also designed a proprietary class for commonly used physical quantities. For example, the physical quantity of the length type is Length, which can be found in pq. quantity calculating The calculation is also very simple. code show as below: 1 2 3 4 5 6 7 8 9 10 11 import quantities as pq q_type = pq . LengthType l = pq . Quantity ( 22 , q_type ) l1 = l . to_unit ( q_type . k_unit ) t = pq . Time ( 11 ) v = l1 . divide ( t ) print ( v . value ) print ( v . current_unit . symbol ()) print ( v . current_unit . express_by_SI ()) print ( v . current_unit . express_by_SI_base ()) The unit of the calculation result is the SI coherent unit of the result quantity type. Because there are three ways to express the SI unit, one is to use the symbol of the unit, for example, the basic unit uses its symbol to express the unit, and some derived units use the power product of the basic unit, and some also use the power product of basic unit and the derived unit with the specific name. To express these measurement units in various documents, there are Latex expressions and html expressions, so the Unit class provides three methods for expressing a certain unit, and each method returns two expressions. When writing a document, the method that needs to be used in the program is determined by the user. The user needs to fully understand the writing method of units in the SI unit system, and this professional domain knowledge. It also supports calculations under traditional codes: 1 2 3 4 5 6 7 import quantities as pq q_type = pq . LengthType l = pq . Quantity ( 22 , q_type ) l1 = l . to_unit ( q_type . k_unit ) t = pq . Time ( 11 ) v = l1 / t It also supports the calculation of physical quantities and single real numbers (or integers), such as: 1 2 3 4 5 6 7 8 import quantities as pq q_type = pq . LengthType l = pq . Quantity ( 22 , q_type ) l1 = l . to_unit ( q_type . k_unit ) l2 = 32 * l1 l3 = l1 * 32 l4 = l1 / 32 However, the physical meaning of the calculation between a quantity and an integer or a real number is not clear. This way of writing is not recommended and I prefer to write the following code. This physical meaning is very clear. 1 2 3 4 5 6 7 8 9 import quantities as pq q_type = pq . LengthType l = pq . Quantity ( 22 , q_type ) l1 = l . to_unit ( q_type . k_unit ) i = pq . Identity ( 32 ) l2 = i * l1 l3 = l1 * i l4 = l1 / i Identity is a physical quantity without a unit. The calculation result of multiplication and division between it and any physical quantity is the same as that of the original physical quantity, which has a clear physical meaning. Through this kind of clear knowledge of the type of new physical quantity generated at every step, we only need to be familiar with the modeling field, or with the help of domain experts, the bugs in the program will be reduced a lot, even if there is a bug, because the concept is clear, the debug is also It will be easier.","title":"Usage"},{"location":"Usage.html#usage","text":"","title":"Usage"},{"location":"Usage.html#physical-quantity-modeling","text":"Users always perform arithmetic operations such as addition, subtraction, multiplication, and division for physical quantities. These operations are the same, so the interfaces of their physical quantity objects are also the same. For this purpose, a class Quantity is used to express the physical quantity. It provides users with a general arithmetic operation interface, and also provides users with an interface to access this physical quantity type. Of course, it also provides operations for setting and obtaining the current unit of measurement. Use the quantity type class to distinguish the type of physical quantity, for example, use class LengthType as the type of quantity object for length quantity. The quantity type is responsible for generating the corresponding SI unit, checking the legality of addition, subtraction, multiplication and division between two objects, generating a new quantity, and responsible for the unit conversion of the quantity. Each physical quantity has its own unit of measurement. Use class Unit to express these units. Each type of physical quantity has its own set of units. These units are automatically created when creating the class of their physical quantity type, and can be selected by the user according to the corresponding type class.","title":"Physical quantity modeling"},{"location":"Usage.html#create-a-quantity-instance","text":"It is very simple to create an instance of a physical quantity, the following is a code example: 1 2 3 4 import quantities as pq q_type = pq . LengthType current_u = q_type . G_unit l = pq . Quantity ( 22 , q_type , current_u ) If you use the default SI coherent unit, you do not need to give the unit to the constructor. 1 2 3 import quantities as pq q_type = pq . LengthType l = pq . Quantity ( 22 , q_type ) The unit of the quantity object of this length type is meter. If you want to convert to other units, such as kilometers, the code can be written as: 1 l1 = l . to_unit ( q_type . k_unit ) Set the unit of the quantity by the quantity type, such as LengthType, to ensure the corresponding relationship between the quantity and the unit. For ease of use, Physical Quantity calculating has also designed a proprietary class for commonly used physical quantities. For example, the physical quantity of the length type is Length, which can be found in pq.","title":"create a quantity instance"},{"location":"Usage.html#quantity-calculating","text":"The calculation is also very simple. code show as below: 1 2 3 4 5 6 7 8 9 10 11 import quantities as pq q_type = pq . LengthType l = pq . Quantity ( 22 , q_type ) l1 = l . to_unit ( q_type . k_unit ) t = pq . Time ( 11 ) v = l1 . divide ( t ) print ( v . value ) print ( v . current_unit . symbol ()) print ( v . current_unit . express_by_SI ()) print ( v . current_unit . express_by_SI_base ()) The unit of the calculation result is the SI coherent unit of the result quantity type. Because there are three ways to express the SI unit, one is to use the symbol of the unit, for example, the basic unit uses its symbol to express the unit, and some derived units use the power product of the basic unit, and some also use the power product of basic unit and the derived unit with the specific name. To express these measurement units in various documents, there are Latex expressions and html expressions, so the Unit class provides three methods for expressing a certain unit, and each method returns two expressions. When writing a document, the method that needs to be used in the program is determined by the user. The user needs to fully understand the writing method of units in the SI unit system, and this professional domain knowledge. It also supports calculations under traditional codes: 1 2 3 4 5 6 7 import quantities as pq q_type = pq . LengthType l = pq . Quantity ( 22 , q_type ) l1 = l . to_unit ( q_type . k_unit ) t = pq . Time ( 11 ) v = l1 / t It also supports the calculation of physical quantities and single real numbers (or integers), such as: 1 2 3 4 5 6 7 8 import quantities as pq q_type = pq . LengthType l = pq . Quantity ( 22 , q_type ) l1 = l . to_unit ( q_type . k_unit ) l2 = 32 * l1 l3 = l1 * 32 l4 = l1 / 32 However, the physical meaning of the calculation between a quantity and an integer or a real number is not clear. This way of writing is not recommended and I prefer to write the following code. This physical meaning is very clear. 1 2 3 4 5 6 7 8 9 import quantities as pq q_type = pq . LengthType l = pq . Quantity ( 22 , q_type ) l1 = l . to_unit ( q_type . k_unit ) i = pq . Identity ( 32 ) l2 = i * l1 l3 = l1 * i l4 = l1 / i Identity is a physical quantity without a unit. The calculation result of multiplication and division between it and any physical quantity is the same as that of the original physical quantity, which has a clear physical meaning. Through this kind of clear knowledge of the type of new physical quantity generated at every step, we only need to be familiar with the modeling field, or with the help of domain experts, the bugs in the program will be reduced a lot, even if there is a bug, because the concept is clear, the debug is also It will be easier.","title":"quantity calculating"},{"location":"add_new_quantity.html","text":"Add A New Quantity Adding a new quantity is very simple, you need to inherit two new classes from the two classes QuantityType and Unit. The former expresses a new type of physical quantity, and the latter expresses a new unit corresponding to the type of physical quantity.Detailed examples can be found in the design of mass and energy . Designing new SI unit class Add an new unit class is very simple. The code is as following: 1 2 3 4 5 6 7 class joule ( Unit ): profile = { \"name\" : \"joule\" , \"symbol\" : \"J\" , \"express_by_SI_base\" : \"kg*m+2*s-2\" , \"express_by_SI\" : \"N*m\" } This class is the primary class of the physical quantity type, and other unit classes are related to this class. For example, it is the basis for automatically generating prefix unit classes, and it is also a transitional unit class for unit conversion. Most of the time, it is the coherent unit of the SI unit system. But there are exceptions. For example, in the unit of mass, g is the primary unit, but it is not the coherent unit selected by SI unit system. The coherent unit is kg. For the unit class added in the new design, Physical Quantity Calculating does not know its name, symbol, and how to express it in the basic unit of the SI unit system and the derived unit with a specific name, so it needs to provide a reference when designing. This reference is placed in its class variable profile. It needs to be set as a dict object. Its four keys respectively represent the name and symbol of the primary unit, the expression in the basic unit, and the expression in the basic unit and the derived unit with a specific name. The value corresponding to each key is determined by the unit. If the unit does not have this value, it is an empty string. If so, it needs to be delivered to Physical Quantity Calculating according to the following principles: The name or symbol and power exponent of each unit must be separated by +, -, * and /. The division sign specified by the SI unit system is still separated by the division sign, such as m/s. If the division sign is not specified, it is separated by a multiplication sign, such as kg*m in joule class. A symbol and its power exponent are separated by plus and minus signs. The plus sign represents a positive power exponent, and the minus sign represents a negative power exponent. For example, m+2 in the joule class. The power exponent of the previous symbol and the next symbol are separated by a multiplication sign. For example, 2*s in the joule class. There must be no spaces before and after the symbol or the two expression strings. Therefore, in the joule class, its symbol is J. And it needs to be written as kg*m+2*s-2 when expressed in the basic unit of the SI unit system, and as N*m when expressed in the basic unit and unit with specific name. Their real expressions would be \\(kg\\cdot m^{2}\\cdot s^{-2}\\) and \\(N\\cdot m\\) (This display is the display of Latex on the web page. If you use html display, it will be kg\u00b7m 2 \u00b7s -2 ). Of course, the expression method m/s stipulated by the SI unit system will still be retained. Design non-SI unit class There is no fundamental difference between designing non-SI units and designing SI units. However, the conversion relationship between non-SI units and SI primary units is not necessarily a proportional relationship. For example, the relationship between the thermodynamic temperature unit kevin and celsius\u3000degree is a linear relationship rather than a simple proportional relationship. So when designing a non-SI unit, you need to override two methods to_pri_unit and from_pri_unit . The following is an example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class celsius_degree ( Unit ): profile = { \"name\" : \"celsius degree\" , \"symbol\" : \"\u00b0\" , \"express_by_SI_base\" : \"\" , \"express_by_SI\" : \"\" } @classmethod def to_pri_unit ( cls , value ): return value + 273.15 @classmethod def from_pri_unit ( cls , value ): return value - 273.15 class fahrenheit_degree ( Unit ): profile = { \"name\" : \"fahrenheit degree\" , \"symbol\" : \"F\" , \"express_by_SI_base\" : \"\" , \"express_by_SI\" : \"\" } @classmethod def to_pri_unit ( cls , value ): return ( 5 / 9 ) * ( value - 32 ) + 273.15 @classmethod def from_pri_unit ( cls , value ): return ( 9 / 5 ) * ( value - 273.15 ) + 32 Design unit conversion relationship If you want to establish a conversion relationship between each unit, the workload is huge and difficult to complete. It should be particularly pointed out here that the method of establishing the conversion between each pair of units in the Physical Quantity Calculating class library uses the analysis pattern of Martin Fowler. For details, see the pattern of Figure 3.3 in UML Diagrams for Chapter 3 of Analysis Patterns Design new quantity type The design of a new quantity type needs to inherit the class QuantityType. For example, to design EnergyType, the code is as follows: 1 2 3 4 5 6 7 8 9 10 11 12 class EnergyType ( QuantityType ): pri_unit = joule SI_conherent_unit = pri_unit @classmethod def register_type ( cls ): cls . source [( ForceType , '*' , LengthType )] = cls cls . source [( LengthType , '*' , ForceType )] = cls cls . source [( cls , '/' , ForceType )] = LengthType cls . source [( cls , '/' , LengthType )] = ForceType @classmethod def register_type ( cls ): pass In the class design of this physical quantity, the first thing we have to set is its primary unit. In this EnergyType class, it is the class joule that we designed in the previous section. So we set the class variable pri_unit of the EnergyType class equals joule .EnergyType will generate its corresponding prefixed unit based on this unit. Similarly, it is also a transitional unit for unit conversion. We will discuss this point below. The second class variable that needs to be set in the EnergyType class is SI_coherent_unit . It is the coherent unit of the SI unit. In the physical quantity of the EnergyType type, this unit is its primay. So we set SI_coherent_unit = pri_unit . It should be noted that in the SI unit system, most of the primary units of physical quantities are consistent with the coherent units of the SI unit system. But there are exceptions. For example, the primary unit of MassType is g instead of kg. But kg is the basic unit of SI, and it is also a coherent unit. When the class QuantityType is inherited for designing a new physical quantity type, a key class method register_type needs to be overridden. In QuantityType, this method is designed to throw NotImplementedError, the purpose is to remind programmers who inherit this class to override this method. This method needs to determine the multiplication and division relationship between related physical quantities, and this is the basis for the automatic generation of physical quantities by Physical Quantity Calculating. The overriding class method register_type method determines that the quantity type can be obtained by multiplying or dividing the two other types. For example, the definition of EnergyType is the work done by force through a certain displacement, so it can be considered to be obtained by multiplying ForceType by LengthType. Therefore, in this method, the corresponding item should be added to the source dictionary of the class variable. The key to be added to the dictionary is a tuple. The tuple consists of two classes of physical quantity types and the corresponding multiplication or division signs. For example, EnergyType is obtained by multiplying ForceType and LengthType, so its key is composed of tuples ( ForceType , '*' , LengthType ) . And its value is EnergyType. Therefore, when overriding the class method register_type, first add this value to the source dictionary, that is, the code: 1 2 3 4 cls . source [( ForceType , '*' , LengthType )] = cls cls . source [( LengthType , '*' , ForceType )] = cls cls . source [( cls , '/' , ForceType )] = LengthType cls . source [( cls , '/' , LengthType )] = ForceType When overriding the register_type method, add as many meaningful operations as possible to the dictionary specified by source. For example, in the design of EnergyType, in addition to the first sentence expressing the definition of EnergyType, the second sentence also expresses its definition. The corresponding EnergyType and the division results of LengthType and ForceType are also meaningful, so write them separately into the dictionary pointed to by source. In this way, when applying Physical Quantity Calculating, when these four situations are encountered, the physical quantity type of the operation result can be determined. In particular, it should be noted that in the design of QuantityType, the class variable source points to an empty dictionary. The source of its subclasses will also point to this dictionary. Each subclass will register for itself the result type of many operations in this dictionary. And in actual operation, the corresponding operation result type will be searched from this dictionary. Therefore, it is strictly forbidden for any subclass to set another dictionary for the source. Otherwise, even if the corresponding physical quantity type has been registered during the design, an error may still be thrown during the calculation process because it cannot be found.Details can be seen in the highlighted part of the aforementioned EnergyType design code snippet If certain subclasses do not need to specifically register certain operations, they must also override the class method register_type to prevent NotImplemenedError from being thrown. See the design of LengthType . When designing a new quantity type, it must also be associated with its non-SI units. For example, when designing the quantity type of thermodynamic temperature, it is necessary to associate the class celsius_degree and the class fahrenheit_degree. After the association, the user can call its non-SI unit through this quantity type.The details can be seen in the following example. 1 2 3 4 5 6 7 8 class ThermodynamicTemperatureType ( QuantityType ): pri_unit = K SI_conherent_unit = pri_unit celsius_degree = celsius_degree fahrenheit_degree = fahrenheit_degree @classmethod def register_type ( cls ): pass Designed physical quantity in the system When this system was released, most of the physical quantity types had been designed based on the content of SI. Details can be seen in the contents of the software package.","title":"Add New Quantity"},{"location":"add_new_quantity.html#add-a-new-quantity","text":"Adding a new quantity is very simple, you need to inherit two new classes from the two classes QuantityType and Unit. The former expresses a new type of physical quantity, and the latter expresses a new unit corresponding to the type of physical quantity.Detailed examples can be found in the design of mass and energy .","title":"Add A New Quantity"},{"location":"add_new_quantity.html#designing-new-si-unit-class","text":"Add an new unit class is very simple. The code is as following: 1 2 3 4 5 6 7 class joule ( Unit ): profile = { \"name\" : \"joule\" , \"symbol\" : \"J\" , \"express_by_SI_base\" : \"kg*m+2*s-2\" , \"express_by_SI\" : \"N*m\" } This class is the primary class of the physical quantity type, and other unit classes are related to this class. For example, it is the basis for automatically generating prefix unit classes, and it is also a transitional unit class for unit conversion. Most of the time, it is the coherent unit of the SI unit system. But there are exceptions. For example, in the unit of mass, g is the primary unit, but it is not the coherent unit selected by SI unit system. The coherent unit is kg. For the unit class added in the new design, Physical Quantity Calculating does not know its name, symbol, and how to express it in the basic unit of the SI unit system and the derived unit with a specific name, so it needs to provide a reference when designing. This reference is placed in its class variable profile. It needs to be set as a dict object. Its four keys respectively represent the name and symbol of the primary unit, the expression in the basic unit, and the expression in the basic unit and the derived unit with a specific name. The value corresponding to each key is determined by the unit. If the unit does not have this value, it is an empty string. If so, it needs to be delivered to Physical Quantity Calculating according to the following principles: The name or symbol and power exponent of each unit must be separated by +, -, * and /. The division sign specified by the SI unit system is still separated by the division sign, such as m/s. If the division sign is not specified, it is separated by a multiplication sign, such as kg*m in joule class. A symbol and its power exponent are separated by plus and minus signs. The plus sign represents a positive power exponent, and the minus sign represents a negative power exponent. For example, m+2 in the joule class. The power exponent of the previous symbol and the next symbol are separated by a multiplication sign. For example, 2*s in the joule class. There must be no spaces before and after the symbol or the two expression strings. Therefore, in the joule class, its symbol is J. And it needs to be written as kg*m+2*s-2 when expressed in the basic unit of the SI unit system, and as N*m when expressed in the basic unit and unit with specific name. Their real expressions would be \\(kg\\cdot m^{2}\\cdot s^{-2}\\) and \\(N\\cdot m\\) (This display is the display of Latex on the web page. If you use html display, it will be kg\u00b7m 2 \u00b7s -2 ). Of course, the expression method m/s stipulated by the SI unit system will still be retained.","title":"Designing new SI unit class"},{"location":"add_new_quantity.html#design-non-si-unit-class","text":"There is no fundamental difference between designing non-SI units and designing SI units. However, the conversion relationship between non-SI units and SI primary units is not necessarily a proportional relationship. For example, the relationship between the thermodynamic temperature unit kevin and celsius\u3000degree is a linear relationship rather than a simple proportional relationship. So when designing a non-SI unit, you need to override two methods to_pri_unit and from_pri_unit . The following is an example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class celsius_degree ( Unit ): profile = { \"name\" : \"celsius degree\" , \"symbol\" : \"\u00b0\" , \"express_by_SI_base\" : \"\" , \"express_by_SI\" : \"\" } @classmethod def to_pri_unit ( cls , value ): return value + 273.15 @classmethod def from_pri_unit ( cls , value ): return value - 273.15 class fahrenheit_degree ( Unit ): profile = { \"name\" : \"fahrenheit degree\" , \"symbol\" : \"F\" , \"express_by_SI_base\" : \"\" , \"express_by_SI\" : \"\" } @classmethod def to_pri_unit ( cls , value ): return ( 5 / 9 ) * ( value - 32 ) + 273.15 @classmethod def from_pri_unit ( cls , value ): return ( 9 / 5 ) * ( value - 273.15 ) + 32","title":"Design non-SI unit class"},{"location":"add_new_quantity.html#design-unit-conversion-relationship","text":"If you want to establish a conversion relationship between each unit, the workload is huge and difficult to complete. It should be particularly pointed out here that the method of establishing the conversion between each pair of units in the Physical Quantity Calculating class library uses the analysis pattern of Martin Fowler. For details, see the pattern of Figure 3.3 in UML Diagrams for Chapter 3 of Analysis Patterns","title":"Design unit conversion relationship"},{"location":"add_new_quantity.html#design-new-quantity-type","text":"The design of a new quantity type needs to inherit the class QuantityType. For example, to design EnergyType, the code is as follows: 1 2 3 4 5 6 7 8 9 10 11 12 class EnergyType ( QuantityType ): pri_unit = joule SI_conherent_unit = pri_unit @classmethod def register_type ( cls ): cls . source [( ForceType , '*' , LengthType )] = cls cls . source [( LengthType , '*' , ForceType )] = cls cls . source [( cls , '/' , ForceType )] = LengthType cls . source [( cls , '/' , LengthType )] = ForceType @classmethod def register_type ( cls ): pass In the class design of this physical quantity, the first thing we have to set is its primary unit. In this EnergyType class, it is the class joule that we designed in the previous section. So we set the class variable pri_unit of the EnergyType class equals joule .EnergyType will generate its corresponding prefixed unit based on this unit. Similarly, it is also a transitional unit for unit conversion. We will discuss this point below. The second class variable that needs to be set in the EnergyType class is SI_coherent_unit . It is the coherent unit of the SI unit. In the physical quantity of the EnergyType type, this unit is its primay. So we set SI_coherent_unit = pri_unit . It should be noted that in the SI unit system, most of the primary units of physical quantities are consistent with the coherent units of the SI unit system. But there are exceptions. For example, the primary unit of MassType is g instead of kg. But kg is the basic unit of SI, and it is also a coherent unit. When the class QuantityType is inherited for designing a new physical quantity type, a key class method register_type needs to be overridden. In QuantityType, this method is designed to throw NotImplementedError, the purpose is to remind programmers who inherit this class to override this method. This method needs to determine the multiplication and division relationship between related physical quantities, and this is the basis for the automatic generation of physical quantities by Physical Quantity Calculating. The overriding class method register_type method determines that the quantity type can be obtained by multiplying or dividing the two other types. For example, the definition of EnergyType is the work done by force through a certain displacement, so it can be considered to be obtained by multiplying ForceType by LengthType. Therefore, in this method, the corresponding item should be added to the source dictionary of the class variable. The key to be added to the dictionary is a tuple. The tuple consists of two classes of physical quantity types and the corresponding multiplication or division signs. For example, EnergyType is obtained by multiplying ForceType and LengthType, so its key is composed of tuples ( ForceType , '*' , LengthType ) . And its value is EnergyType. Therefore, when overriding the class method register_type, first add this value to the source dictionary, that is, the code: 1 2 3 4 cls . source [( ForceType , '*' , LengthType )] = cls cls . source [( LengthType , '*' , ForceType )] = cls cls . source [( cls , '/' , ForceType )] = LengthType cls . source [( cls , '/' , LengthType )] = ForceType When overriding the register_type method, add as many meaningful operations as possible to the dictionary specified by source. For example, in the design of EnergyType, in addition to the first sentence expressing the definition of EnergyType, the second sentence also expresses its definition. The corresponding EnergyType and the division results of LengthType and ForceType are also meaningful, so write them separately into the dictionary pointed to by source. In this way, when applying Physical Quantity Calculating, when these four situations are encountered, the physical quantity type of the operation result can be determined. In particular, it should be noted that in the design of QuantityType, the class variable source points to an empty dictionary. The source of its subclasses will also point to this dictionary. Each subclass will register for itself the result type of many operations in this dictionary. And in actual operation, the corresponding operation result type will be searched from this dictionary. Therefore, it is strictly forbidden for any subclass to set another dictionary for the source. Otherwise, even if the corresponding physical quantity type has been registered during the design, an error may still be thrown during the calculation process because it cannot be found.Details can be seen in the highlighted part of the aforementioned EnergyType design code snippet If certain subclasses do not need to specifically register certain operations, they must also override the class method register_type to prevent NotImplemenedError from being thrown. See the design of LengthType . When designing a new quantity type, it must also be associated with its non-SI units. For example, when designing the quantity type of thermodynamic temperature, it is necessary to associate the class celsius_degree and the class fahrenheit_degree. After the association, the user can call its non-SI unit through this quantity type.The details can be seen in the following example. 1 2 3 4 5 6 7 8 class ThermodynamicTemperatureType ( QuantityType ): pri_unit = K SI_conherent_unit = pri_unit celsius_degree = celsius_degree fahrenheit_degree = fahrenheit_degree @classmethod def register_type ( cls ): pass","title":"Design new quantity type"},{"location":"add_new_quantity.html#designed-physical-quantity-in-the-system","text":"When this system was released, most of the physical quantity types had been designed based on the content of SI. Details can be seen in the contents of the software package.","title":"Designed physical quantity in the system"}]}